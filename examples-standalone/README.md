# Standalone benchmarks

This directory contains benchmarks for the OCaml-extracted interpreters generated from the language definitions in the [../languages](../languages) directory.
The script [test.sh](./test.sh) executes the benchmarks and yields an output similar to the following:
```
== Compilation
Compiling fail-invalid-semantics
Compiling decrement
Compiling decrement-builtin
Compiling arith
Compiling imp
Compiling two-counters

== Native (via OCaml extraction) benchmarks
name, total, parsing, execution
dec-into-2,  0.13,  0.06,  0.00
dec-into-1,  0.13,  0.06,  0.00
dec-builtin-into--1,  0.13,  0.06,  0.00
arith-01,  0.12,  0.06,  0.00
imp-01,  0.12,  0.06,  0.00
imp-count-1,  0.14,  0.06,  0.01
imp-count-2,  0.15,  0.06,  0.02
imp-count-3,  0.16,  0.06,  0.03
imp-count-4,  0.17,  0.06,  0.04
imp-count-5,  0.17,  0.06,  0.04
imp-count-6,  0.18,  0.06,  0.05
imp-count-7,  0.18,  0.06,  0.06
imp-count-10,  0.21,  0.06,  0.08
two-counters.10,  0.13,  0.06,  0.00
two-counters.100,  0.14,  0.06,  0.00
two-counters.1'000,  0.15,  0.06,  0.01
two-counters.10'000,  0.16,  0.06,  0.04
two-counters.100'000,  0.50,  0.06,  0.37
two-counters.1'000'000,  3.83,  0.06,  3.70
```
The table in the section titled `Native (via OCaml extraction) benchmarks` contains the results.
Each row contains one benchmark. The first column contains the name of the benchmark;
the second column the total time to execute the interpreter (generated by the `time` utility); the third column the time needed to execute the parser on the given input;
and the last column the time of the actual execution.
The last two columns are measured by the [OCaml Benchmark package](https://ocaml.org/p/benchmark/latest/doc/Benchmark/index.html).
The last column is the one most interesting one, because it indicates something about the performance of the actual generated interpreter.
The total time is higher than the sum of parsing and execution time: the difference is overhead caused by filesystem manipulation, program loading, etc.
The overhead is non-negligible (over 120 milliseconds in the above example) because Minuska generates a semi-portable executable using the [AppImage technology](https://appimage.org/).
All times are wall clock, in seconds.





